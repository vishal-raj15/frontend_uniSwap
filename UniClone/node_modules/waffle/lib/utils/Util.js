/*
 * Copyright 2012 Katsunori Koyanagi
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
/**
 * @overview ユーティリティ機能を提供します。
 */
"use strict";

/**
 * ユーティリティ機能を提供します。
 * 
 * @class ユーティリティ機能を提供します。
 */
var Util = {};

function getLength(obj) {
	var max = -1;
	for ( var key in obj) {
		var val = parseInt(key, 10);
		if (val * 0.0 === 0.0 && val > -1 && String(val) === key) {
			max = max < value ? value : max;
		}
	}

	return max + 1;
}

/**
 * クエリ文字列やリクエストボディをJavaServletスタイルでパースし、オブジェクトに変換して返します。
 * <p>
 * JavaServletのgetParameterやgetParametersのように、配列もしくは単一の値でのパラメータの取得が行えるよう、
 * 名前に対して値の配列という形式でのオブジェクトを生成します。PHPスタイルのように、配列を示す構文は無視され、
 * 単純に全てブラケット等を含めたものが名前として扱われます。要素数が仮に1つのみでも、配列となります。
 * </p>
 * 
 * @param {String}
 *            query クエリ文字列
 * @return {Object} オブジェクト
 */
Util.parseServletStyleParameters = function(query) {
	var tokens = query.split("&");
	var params = {};
	var duc = decodeURIComponent;

	for ( var i = 0, j = tokens.length; i < j; i++) {
		var token = tokens[i];
		var idx = token.indexOf("=");
		var name;
		var value;

		if (idx === -1) {
			name = duc(token);
			value = "";
		} else if (idx === 0) {
			name = "";
			value = duc(token);
		} else {
			name = duc(token.substr(0, idx));
			value = duc(token.substr(idx + 1));
		}

		var array;
		if (!(name in params)) {
			array = params[name] = [];
		} else {
			array = params[name];
		}

		array[array.length] = value;
	}

	return params;
};

/**
 * クエリ文字列やリクエストボディをPHPスタイルでパースし、オブジェクトに変換して返します。
 * <p>
 * PHPでよく使用される$_GETや$_POST変数と同等にパースすることができます。
 * クエリの変数名の後ろにブラケットを指定することで、配列のインデックスを指定することができます。
 * インデックスを省略したスタイルの場合、現在の最大のインデックスの次に値が設定されます。 多重配列の設定や、名前による設定も可能です。
 * </p>
 * <p>
 * この関数によって返される値が配列スタイルで定義されている場合においても、 オブジェクトは、0や1というメンバを持つ単純なオブジェクトになります。
 * 配列ではありませんので注意してください。
 * </p>
 * 
 * @param {String}
 *            query クエリ文字列
 * @return {Object} オブジェクト
 */
Util.parsePHPStyleParameters = function(query) {
	var tokens = query.split("&");
	var params = {};
	var duc = decodeURIComponent;
	var token, idx, idx2, name, value, key, i, j, k, l, props, prop, target, temp;

	for (i = 0, l = tokens.length; i < l; i++) {
		token = tokens[i];
		idx = token.indexOf("=");
		key = null;

		if (idx === 0) {
			continue;
		}
		if (idx === -1) {
			name = duc(token);
			value = "";
		} else {
			name = duc(token.substr(0, idx));
			value = duc(token.substr(idx + 1));
		}

		idx = name.indexOf("[");
		if (idx > -1) {
			if (name.indexOf("]", idx + 1) > -1) {
				key = name.substr(idx);
				name = name.substr(0, idx);
			}
		}
		name = name.replace("[", "_");

		if (key !== null) {
			props = [];
			k = 0;

			while (true) {
				idx = key.indexOf("[", 0);
				if (idx !== 0) {
					break;
				}
				idx2 = key.indexOf("]", idx);
				if (idx2 === -1) {
					break;
				}
				prop = key.substring(idx + 1, idx2);
				key = key.substr(idx2 + 1);

				if (prop === "") {
					props[k++] = null;
					continue;
				}

				props[k++] = prop;
			}

			target = params[name];
			if (!Array.isArray(target)) {
				target = params[name] = Object.create(null);
			}

			for (j = 0; j < k - 1; j++) {
				prop = props[j] === null ? getLength(target) : props[j];
				temp = target[prop];
				if (!Array.isArray(temp)) {
					target[prop] = temp = Object.create(null);
				}
				target = temp;
			}

			target[props[--k] === null ? getLength(target) : props[k]] = value;
		} else {
			params[name] = value;
		}
	}

	return params;
}

var internalId = 0;

/**
 * ユニークなID文字列を生成します。
 * 
 * @return ID文字列
 */
Util.generateUID = function() {
	var pre = "0000000000000000";
	var time = (pre + Date.now().toString(16)).substr(-16);
	var pid = (pre + process.pid.toString(16)).substr(-4);
	pid += "0000";
	pid += (pre + Math.floor(Math.random() * 0xffff).toString(16)).substr(-8);
	internalId = (++internalId) & 0xffffffff;
	var id = (pre + internalId.toString(16)).substr(-16);
	var random = (pre + Math.floor(Math.random() * 0xffffffff).toString(16))
			.substr(-16);

	var result = "", i;
	for (i = 0; i < 8; i++) {
		var x = 15 - i;
		var y = i;
		result += time[x];
		result += pid[x];
		result += id[x];
		result += random[x];
		result += time[y];
		result += pid[y];
		result += id[y];
		result += random[y];
	}

	return result;
};

//
// expose
//
module.exports = Util;
